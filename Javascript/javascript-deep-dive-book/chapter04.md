# 🔎 변수

## ✨ 변수란 무엇인가? 왜 필요한가?

프로그램으로 만들어낸 아무리 복잡한 애플리케이션이라고 해도 결국은, 데이터를 입력 받아서 처리하고 그 결과를 출력하는 것이 전부입니다.
변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념입니다. 변수란 무엇인지, 왜 필요한지 함께 살펴봅시다 🙌

```javascript
10 + 20;
```

위의 코드를 실행하면 컴퓨터에서는 어떤 일이 일어날까요

자바스크립트 엔진이 위 코드를 계산 하려면 먼저 10, 20, + 라는 기호(리터럴과 연산자)의 의미를 알고 있어야 하며, 10 + 20이라는 식(표현식)의 의미도 해석할 수 있어야 합니다. 자바스크립트 엔진이 + 연산을 수행하기 위해 먼저 + 연산자의 좌변과 우변의 숫자 값(피연산자)을 기억합니다.

조금 더 깊숙히 들어가볼까요?

컴퓨터는 연산과 기억을 수행하는 부품이 나누어져 있습니다. CPU를 통해서 연산을 하고 메모리를 사용해 데이터를 기억하죠.

위의 예제로 보면 숫자 값 10과 20은 메모리 중 임의의 위치(메모리 주소)에 기억(저장)되고, CPU는 이 값을 읽어드려 연산을 수행하게 됩니다. 연산 결과로 생성된 숫자 값인 30도 메모리 상의 임의의 위치(메모리 주소)에 저장됩니다.

하지만 이 30이라는 값을 재사용하려 메모리 공간에 직접 접근하게 된다면 치명적 오류를 발생시킬 가능성이 높은 매우 위험한 일이기 때문에 **자바스크립트는 개발자의 직접적인 메모리 제어**를 허용하지 않습니다.

위의 이유로 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공합니다.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름으로 쉽게 이야기 하자면, **값의 위치를 가르키는 상징적인 이름**입니다.

메모리 공간에 저장된 저장된 값을 식별할 수 있는 고유한 이름을 변수 리음이라고 하며 저장된 값은 변수 값이라고 합니다.

변수에 값을 저장하는 것을 **할당**이라고 하고 변수에 저장된 값을 읽어들이는 것을 **참조**라고 합니다.

## ✨ 식별자

변수 이름을 식별자라고도 합니다. 식별자는 이름 그대로 어떤 값을 구별하여 식별할 수 있는 고유한 이름을 말합니다. 사람을 이름으로 구별하여 식별하는 것처럼 값도 식별자고 구별해서 식별할 수 있습니다.

식별자는 값이 아니라 메모리 주소를 기억하고 있습니다. 식별자로 값을 구별해서 식별한다는 것은 <u>식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미</u>입니다. 즉, **식별자는 메모리 주소에 붙인 이름**이라고 할 수 있습니다.

이 식별자 라는 용어는 변수 이름에만 국한되어 사용되는 것이 아닌, 변수, 함수, 클래스 등의 이름들을 모두 식별자라고 할 수 있습니다.

즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름들을 모두 식별자라고 부르는 것이죠.

## ✨ 선언

변수 선언이란 변수를 생성하는 것을 말합니다. 변수 생성은 어떻게 하는 것일까요?

자세히 말하자면 값을 저장하기 위해 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있도록 준비하는 과정을 이야기 합니다. 변수 선언에 의해 확보된 메모리 공간은 확보가 해제되지 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되기 때문에 안전하게 사용 가능합니다.

변수를 사용하려면 반드시 선언이 필요합니다. 자바스크립트에서 변수를 선언할 때에는 `var` `let` `const` 라는 키워드를 사용합니다.

**변수가 선언되면 일어나는 일**

- 선언 단계 : 변수의 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알립니다.
- 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고, 암묵적으로 undefined를 할당합니다.

초기화 단계를 거치지 않을 경우에는, 메모리에 이전에 다른 어플리케이션이 사용했던 값이 남아 있을 수 있는데, 이를 쓰레기값이라고 합니다. 쓰레기값이 저장되어 있을 경우 예기치 못 한 문제가 발생할 수 있지만, 자바스크립트에서는 암묵적으로 undefined 를 할당하므로 이러한 위험으로부터 안전합니다.

**선언하지 않은 식별자에 접근하면 일어나는 일**

```
console.log(average)
```

![ReferenceError]()

위의 코드를 작헝했을 때 우리는 오류를 만날 수 있습니다.
만약, 선언하지 않은 식별자에 접근하게 된다면 `ReferenceError(참조에러)`가 발생하게 됩니다.

ReferenceError 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진에 등록된 식별자를 찾을 수 없을 때, 발생하는 에러입니다.

### ES5 vs ES6 변수 선언의 차이점

`let`과 `const` 키워드가 도입되기 전까지는 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드는 `var`였습니다.

| -      | var            | let         | const       |
| ------ | -------------- | ----------- | ----------- |
| scope  | function level | block level | block level |
| 재선언 | O              | X           | X           |
| 재할당 | O              | O           | X           |

var 키워드에는 여러가지 단점이 있습니다. 그 중 가장 대표적인 것이 **블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원**한다는 것입니다. 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생한다고 합니다.

[스코프](https://poiemaweb.com/js-scope#3-function-level-scope)

- 블록 레벨 스코프 : 코드 블록 내에서 유호한 스코프를 의미
- 함수 레벨 스코프 : 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것을 의미

## ✨ 변수 선언의 실행 시점과 변수 호이스팅

변수 선언의 실행 시점을 알아보기 위해 아래의 예제 코드를 봐주세요.

```javascript
console.log(score);
var score;
```

변수 선언문보다 변수를 참조하는 코드가 앞에 있습니다. 자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행되기 때문에 `console.log(score)` 이라는 명령어가 먼저 실행됩니다.

그렇다면 위에서 배운 것 처럼 저희는 ReferenceError(참조 에러)가 발생할 것이라고 예상할 수 있겠지만 아쉽게도 콘솔에는 `undefined`가 출력됩니다. 어떻게 된 일일까요?

그 이유는, <u>변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행</u>되기 때문입니다.

**이 처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 합니다.**

> 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기 전에 먼저 소스코드의 평가 과정을 거치며 소스 코드 실행 준비를 합니다. 이때 준비 단계인 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내어 먼저 실행합니다.

## ✨ 값의 할당

변수에 값을 할당할 때는 할당 연산자인 = 을 사용합니다. 할당 연산자는 우변의 값을 좌변에 변수에 할당합니다.

```javascript
var score; // 변수 선언
score = 80; // 변수 할당

var score = 80; // 변수 선언 + 변수 할당
```

변수 선언과 값의 할당의 실행 시점은 다릅니다. **변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행됩니다.**

그렇다면 선언과 할당을 동시에 할 경우에는 어떻게 될까요?

변수의 선언과 할당을 하나의 문장으로 단축하여 표현하여고 자바스크립트 엔진은 변수의 선언과 값의 할당을 2개의 문으로 나누어 각각 실행하기 때문에 아래와 같은 결과가 나옵니다.

```javascript
console.log(score); // undefined
var score = 80;
console.log(score); // 80
```

아래의 코드는 어떤 결과를 가져올까요?

```javascript
console.log(score); //undefined
score = 80;
var score;
console.log(score); // 80
```

## ✨ 값의 재할당

var 키워드로 선언한 변수는 값을 재할당 할 수 있습니다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것입니다. 변수에 값을 처음 할당하는 것도 사실 재할당이라고 볼 수 있습니다.

**만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라고 합니다.**

재할당을 하면 메모리에는 어떤식으로 저장될까요? 첫번째 값이 저장된 메모리 공간이 지워지고 그 안에 다시 재할당 값이 들어가는 것일까요?

아닙니다! 처음 값을 할당했을 때와 마찬가지로 새로운 메모리 공간을 확보한 뒤 그 메모리 공간에 재할당 값을 저장합니다. 다만, 첫 번째 값이 저장된 메모리 공간은 더 이상 필요하지 않기 때문에 **가비지 콜렉터에 의해 메모리에서 자동 해제**됩니다.

## ✨ 식별자 네이밍 규칙

1. 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호를 포함할 수 없다.
2. 단 식별자는 특수문자를 데외한 문자, 언더스코어(\_), 달러 기호로 시작해야 한다.
3. 숫자로 시작하는 것은 허용하지 않는다.
4. 예약어는 식별자로 사용할 수 없다.
